---
title: "Tadpole Mortality"
subtitle: "Métodos Analíticos"
editor: visual
authors:
  - "Mario Medina - 156940"
  - "José Eduardo Gutierrez - "
  - "Mariano Villafuerte - 156057"
format: 
    html:
      toc: TRUE
      embed-resources: TRUE
      theme: flatly
      lang: es
      font-size: 1.1em
      include-in-header: 
      - text: |
          <style>
            body { 
              line-height: 2; /* Adjust the value as needed */
            }
          </style>
---

```{r librerias}
#| echo: FALSE
#| message: FALSE
#| warning: FALSE

knitr::opts_chunk$set(cache = TRUE)

# librerias ----
# library(cmdstanr)
library(coda)
library(dagitty)
library(DiagrammeR)
library(gt)
library(loo)
library(mvtnorm)
library(patchwork)
library(rethinking)
library(rstan)
library(scales)
library(shape)
library(tidyverse)

# configuracion de ggplot ----
theme_set(theme_minimal())

# cargamos los datos de reedfrogs ---
data(reedfrogs)
```

## Problema {#sec-problema}

En nuestro proyecto, utilizamos datos del estudio de Vonesh, J. R. y Bolker, B. M. (2005), el cual examina cómo las ranas de junco del este de África (Hyperolius spinigularis) adaptan sus tiempos de eclosión en respuesta a los depredadores. Este estudio original mostró que, a pesar de las expectativas, las larvas que eclosionaron temprano por presión de los depredadores no solo sobrevivieron, sino que lo hicieron mejor que las larvas de nidadas no perturbadas. Estos hallazgos sugieren que los costos y beneficios asociados con la plasticidad en la eclosión pueden no ser tan directos como se pensaba anteriormente.

Nuestro proyecto toma estos datos y resultados para construir un modelo Bayesiano jerárquico. El objetivo es profundizar en la comprensión de cómo las respuestas compensatorias de las larvas pueden alterar los compromisos tradicionalmente asociados con la plasticidad de eclosión inducida por depredadores. El modelo que desarrollamos intenta capturar la dinámica de crecimiento compensatorio y las tasas de depredación específicas de tamaño y densidad que pueden explicar mejor las altas tasas de supervivencia observadas en las larvas eclosionadas temprano. Nuestros análisis proporcionan una perspectiva más matizada sobre cómo las decisiones de eclosión temprana influyen en la supervivencia y el desarrollo posterior de las ranas, indicando que los verdaderos costos de estas decisiones emergen más adelante en la vida de las larvas.

Este enfoque modela matemáticamente las interacciones complejas y ofrece nuevas vías para entender las estrategias adaptativas en anfibios frente a amenazas ambientales.

## Datos {#sec-datos}

Utilizamos el conjunto de datos de *reedfrogs* disponible en la librería de *rethinking*. Las instrucciones para instalar la librería y cargar los datos están disponibles en el Anexo 1: *Rethinking y sus datos*.

Para este problema contamos inicialmente con 5 variables:

| Variable | Descripción                                   |
|----------|-----------------------------------------------|
| density  | Densidad inicial de renacuajos                |
| pred     | Factor indicador de presencia de depredadores |
| size     | Factor del tamaño de los renacuajos           |
| surv     | Número de renacuajos que sobrevivieron        |
| propsurv | Proporción de supervivencia                   |

El conjunto de datos cuenta con información de 48 tanques clasificados en pequeños, medianos y grandes, dependiendo de la densidad de renacuajos en cada uno. Además, disponemos de datos sobre la supervivencia y la tasa de supervivencia en cada tanque.

```{r dataframe_calc}
#| echo: FALSE
df <- reedfrogs

# Add an index column to the data frame
df <-  df %>% mutate(tank = seq(NROW(df)))
df$index <- seq.int(nrow(df))

# Calculate the mean of propsurv
mean_propsurv <- mean(df$propsurv)
```

```{r scatter1}
#| echo: FALSE
# Create the scatterplot with annotations
p <- ggplot(df, 
            aes(x = index, 
                y = propsurv)) +
  geom_point() +
  geom_hline(yintercept = mean_propsurv, 
             linetype = "dashed", 
             color = "blue4") +
  annotate("text", 
           x = max(df$index) - 23, 
           y = mean_propsurv + 0.05, 
           label = "Promedio de supervivencia en tanques", 
           color = "grey", fontface = "italic", hjust = 0) +  
  labs(x = "Tanque", y = "Tasa de Supervivencia") +
  theme(
    axis.title.x = element_text(face = "italic"),
    axis.title.y = element_text(face = "italic")) +
  scale_x_continuous(breaks = c(8, 24, 40), 
                     labels = c("1 <= Pequeño < 16", 
                                "16 <= Mediano < 32", 
                                "32 <= Grande < 48")) +
  geom_vline(xintercept = 16, 
             color = "cyan3")+
  geom_vline(xintercept = 32, 
             color = "cyan3")+
  geom_vline(xintercept = 48, 
             color = "cyan3") +
  scale_y_continuous(labels = scales::percent_format())

p
```

Hay mucha variación en estos datos. Parte de la variación proviene del tratamiento experimental, pero mucha también proviene de otras fuentes. Pensemos en cada fila como un “tanque,” un entorno experimental que contiene renacuajos. Hay muchas cosas peculiares de cada tanque que no se miden, y estos factores no medidos crean variación en la supervivencia entre tanques, incluso cuando todas las variables predictoras tienen el mismo valor. Se realizan múltiples observaciones, en este caso los renacuajos, dentro de cada grupo.

Tenemos medidas repetidas y heterogeneidad entre grupos. Si ignoramos los grupos, asignando el mismo intercepto a cada uno de ellos, corremos el riesgo de ignorar una variación importante en la supervivencia. Esta variación podría enmascarar la asociación con otras variables. Si en su lugar estimamos un intercepto único para cada grupo, utilizando una variable dummy para cada tanque, estaríamos practicando una especie de amnesia. Después de todo, los tanques son diferentes, pero cada tanque nos ayuda a estimar la supervivencia en los otros tanques. Por lo tanto, no tiene sentido olvidar por completo, pasando de un tanque a otro.

## DAG

El modelo jerárquico que proponemos pretende capturar estas complejas interacciones entre la densidad, la tasa de supervivencia y otros factores clave para proporcionar una comprensión más profunda de las estrategias adaptativas de las ranas frente a las amenazas de los depredadores.

```{r dag_graph}
#| echo: FALSE
grViz("
digraph {
  graph [ranksep = 0.2, rankdir=LR]
  node [shape=plaintext]
    S
    T
    D
    G
    P
  edge [minlen = 5]
   T -> S
   D -> S
   G -> S
   P -> S
}
", width = 150, height = 60)
```

Con

-   $\textrm{T}=\textrm{Tanque}$

-   $\textrm{D}=\textrm{Densidad inicial}$

-   $\textrm{G}=\textrm{Tamaño}$

-   ${P}=\textrm{Depredadores}$

-   $\textrm{S}=\textrm{Supervivencia}$

## Modelo Completamente Agrupado

En un primer intento, se puede considerar un modelo del estilo:

$$
S_i \sim \textrm{Binomial}(D_i,p_i)
$$

$$
\textrm{logit}(p_i) = \alpha
$$

$$
\alpha = \textrm{Normal}(0, 1.5)
$$

Lo cual se traduce en el siguiente código en Stan:

```{stan output.var="m_1"}
data {
  int<lower=0> T;         // Num de tanques
  int<lower=0> S[T];         // Num de renacuajos que sobrevivieron
  int<lower=0> D[T];         // Densidad inicial
}

parameters {
  real alpha;                // Un alpha para todos los tanques
}

model {
  // Prior de aplha
  alpha ~ normal(0, 1.5);
  
  for (t in 1:T) {
    S[t] ~ binomial(D[t], inv_logit(alpha));
  }
}

generated quantities {
  int S_rep[T]; 

  // Predicciones basadas en probabilidad comun
  for (t in 1:T) {
    S_rep[t] = binomial_rng(D[t], inv_logit(alpha));
  }
}

```

En este caso, todos los tanques comparten una misma $\alpha$ (*complete pooling*). Es decir, el modelo considera que todos los tanques tienen una misma probabilidad de supervivencia para los renacuajos. Este modelo no considera la variabilidad que pueda haber entre tanques más que la generada por la densidad inicial.

```{r ajuste_m1}
#| echo: FALSE
#| message: FALSE
#| warning: FALSE

dat <- list(
  "T" = max(df$tank),
  S = df$surv,
  D = df$density
)

fit1 <- rstan::sampling(m_1, 
                 data = dat, 
                 iter = 1000, 
                 chains = 2, 
                 cores = 2,
                 refresh=0)
```

Podemos ver los resultados de nuestro primer modelo para la estimación de $\alpha$.

```{r print_m1_results}
#| echo: FALSE
#| warning: FALSE
#| message: FALSE

fit1_summary <- rstan::summary(fit1, 
                               probs = c(0.025,
                                         0.5,
                                         0.975))$summary 

fit1_summary |> 
  as.data.frame() |>
  rownames_to_column("parameter")  |>
  select(parameter,mean, sd, "2.5%", "50%", "97.5%", n_eff, Rhat) |>
  filter(parameter=='alpha' | parameter=='lp__')|>
  gt() |>
  fmt_number()
```

E igualmente podemos comparar nuestras predicciones contra los datos originales:

```{r predictions_m1}
#| echo: FALSE

post1 <- as.data.frame(fit1, pars = c('S_rep'))
df$urv_est <- post1 %>% colMeans
df$propsurv_est <- df$urv_est/df$density

alpha1 <- as.data.frame(fit1, pars = c('alpha')) 
alpha_est <- alpha1$alpha %>% mean() %>% plogis

# Create the scatterplot with annotations
p <- ggplot(df, 
            aes(x = index, 
                y = propsurv_est)) +
  geom_point(data=df, 
          aes(x = index, 
              y = propsurv), color='grey')+
  geom_point(color = 'blue3') +
  geom_hline(yintercept = alpha_est, 
             linetype = "dashed", 
             color = "blue4") +
  # annotate("text", 
  #          x = max(df$index) - 23, 
  #          y = alpha_est + 0.05, 
  #          label = "Promedio de supervivencia en tanques", 
  #          color = "black", 
  #          fontface = "italic", 
  #          hjust = 0) +  
  labs(x = "Tanque", 
       y = "Tasa de Supervivencia") +
  theme(
    axis.title.x = element_text(face = "italic"),
    axis.title.y = element_text(face = "italic")
  ) +
  scale_x_continuous(breaks = c(8, 24, 40), 
                     labels = c("1 <= Pequeño < 16", 
                                "16 <= Mediano < 32", 
                                "32 <= Grande < 48")) +
  geom_vline(xintercept = 16, color = "cyan3")+
  geom_vline(xintercept = 32, color = "cyan3")+
  geom_vline(xintercept = 48, color = "cyan3")+
  # ylim(0, 1) +
  scale_y_continuous(labels = scales::percent_format())

p
```

Y podemos observar que las predicciones (puntos azules) se ajustan al promedio de supervivencia en los tanques (línea punteada azul). Vemos que este modelo nos lleva a un subajuste. En gris apreciamos los datos originales.

## Modelo No Agrupado

Otra opción que tenemos es asumir que cada tanque tiene su propia $\alpha$ y que no podemos obtener información para un tanque al observar los otros tanques. De tal manera que:

$$ S_i \sim \textrm{Binomial}(D_i,p_i) $$

$$ \textrm{logit}(p_i) = \alpha_i $$

$$ \alpha_i = \textrm{Normal}(0, 1.5) $$

Lo cual se traduce en el siguiente código de Stan:

```{stan output.var="m_2"}
data {
  int<lower=0> T;             // Número de tanques
  int<lower=0> S[T];          // Número de sobrevivientes
  int<lower=0> D[T];          // Densidad inicial
}

parameters {
  real alpha[T];              // alpha para cada tanque
}

model {
  // Priors para cada alpha_i
  for (i in 1:T) {
    alpha[i] ~ normal(0, 1.5);
  }
  
  // Modelo para cada tanque
  for (t in 1:T) {
    S[t] ~ binomial(D[t], inv_logit(alpha[t]));
  }
}

generated quantities {
  int S_rep[T];

  // Generar predicciones 
  for (t in 1:T) {
    S_rep[t] = binomial_rng(D[t], inv_logit(alpha[t]));
  }
}

```

```{r ajuste_m2}
#| echo: FALSE
#| message: FALSE
#| warning: FALSE

dat <- list(
  "T" = max(df$tank),
  S = df$surv,
  D = df$density
)

fit2 <- rstan::sampling(m_2, 
                 data = dat, 
                 iter = 1000, 
                 chains = 2, 
                 cores = 2,
                 refresh=0)
```

Podemos ver los resultados de nuestro segundo modelo para la estimación de $\alpha$.

```{r fit_m2}
#| echo: FALSE
#| warning: FALSE
#| message: FALSE

fit2_summary <- rstan::summary(fit2, 
                               probs = c(0.025,
                                         0.5,
                                         0.975),
                               pars=c('alpha','lp__'))$summary 

fit2_summary |> 
  as.data.frame() |>
  rownames_to_column("parameter") |>
  select(parameter,mean, sd, "2.5%", "50%", "97.5%", n_eff, Rhat) |>
  gt() |>
  fmt_number()
```

```{r predictions_m2}
#| echo: FALSE
#| message: FALSE
#| warning: FALSE

post2 <- as.data.frame(fit2, pars = c('S_rep'))
df$urv_est2 <- post2 %>% colMeans
df$propsurv_est2 <- df$urv_est2/df$density

alpha2 <- as.data.frame(fit2, pars = c('alpha')) 
alpha_est2 <- alpha2$alpha %>% mean() %>% plogis

# Create the scatterplot with annotations
p <- ggplot(df, 
            aes(x = index, 
                y = propsurv_est2)) +
  geom_point(data=df, 
          aes(x = index, 
              y = propsurv), color='grey')+
  geom_point(color = 'blue3') +
  geom_hline(yintercept = alpha_est, 
             linetype = "dashed", 
             color = "blue4") +
  # annotate("text", 
  #          x = max(df$index) - 23, 
  #          y = alpha_est + 0.05, 
  #          label = "Promedio de supervivencia en tanques", 
  #          color = "black", 
  #          fontface = "italic", 
  #          hjust = 0) +  
  labs(x = "Tanque", 
       y = "Tasa de Supervivencia") +
  theme(
    axis.title.x = element_text(face = "italic"),
    axis.title.y = element_text(face = "italic")
  ) +
  scale_x_continuous(breaks = c(8, 24, 40), 
                     labels = c("1 <= Pequeño < 16", 
                                "16 <= Mediano < 32", 
                                "32 <= Grande < 48")) +
  geom_vline(xintercept = 16, color = "cyan3")+
  geom_vline(xintercept = 32, color = "cyan3")+
  geom_vline(xintercept = 48, color = "cyan3")+
  # ylim(0, 1) +
  scale_y_continuous(labels = scales::percent_format())

p
```

## Modelo Parcialmente Agrupado

Pero igualmente se puede optar por un modelo parcialmente agrupado. En este caso, se agregan dos parámetros: $\bar{\alpha}$ y $\sigma$, los cuáles llamaremos hiperparámetros desde este punto. El punto es que, en el modelo anterior, todas las $\alpha_i$ se distribuían Normal con una media y desviación estándar establecida. Con esta modificación, los $\alpha_i$ comparten una misma distribución, lo que le permite transmitir información entre tanques al modelo.

El modelo se ve así:

$$ S_i \sim \textrm{Binomial}(D_i, p_i) $$

$$ \textrm{logit}(p_i) = \alpha_{\textrm{TANK}[i]} $$

$$ \alpha_j \sim \textrm{Normal}(\bar{\alpha}, \sigma) $$

$$ \bar{\alpha} \sim \textrm{Normal}(0, 1.5) $$

$$ \sigma \sim \textrm{Exponential}(1) $$

Lo que se traduce en el siguiente código de Stan:

```{stan output.var="m_3"}
data {
  int<lower=0> T;         // Num de tanques
  int<lower=0> S[T];      // Num de renacuajos que sobrevivieron
  int<lower=0> D[T];      // Densidad inicial
}

parameters {
  real<lower=0> alpha_bar;        // Promedio del alpha
  real<lower=0> sigma_alpha;      // Desv est de los alphas
  vector[T] alpha_tank;           // Alpha de cada tanque
}

model {
  // Hyperpriors 
  alpha_bar ~ normal(0, 1.5);
  sigma_alpha ~ exponential(1);
  // Priors
  alpha_tank ~ normal(alpha_bar, sigma_alpha);

  for (t in 1:T) {
    S[t] ~ binomial(D[t], inv_logit(alpha_tank[t]));
  }
}

generated quantities {
  int S_rep[T]; 

  for (t in 1:T) {
    S_rep[t] = binomial_rng(D[t], inv_logit(alpha_tank[t]));
  }
}
```

```{r ajuste_m3}
#| echo: FALSE
#| message: FALSE
#| warning: FALSE

dat <- list(
  "T" = max(df$tank),
  S = df$surv,
  D = df$density
)

fit3 <- rstan::sampling(m_3, 
                 data = dat, 
                 iter = 1000, 
                 chains = 2, 
                 cores = 2,
                 refresh=0)
```

```{r fit_m3}
#| echo: FALSE
#| warning: FALSE
#| message: FALSE

fit3_summary <- rstan::summary(fit3, 
                               probs = c(0.025,
                                         0.5,
                                         0.975),
                               pars=c('alpha_tank','lp__'))$summary 

fit3_summary |> 
  as.data.frame() |>
  rownames_to_column("parameter") |>
  select(parameter,mean, sd, "2.5%", "50%", "97.5%", n_eff, Rhat) |>
  gt() |>
  fmt_number()
```

Y podemos, nuevamente, ver cómo se comportan nuestras predicciones contra los valores observados.

```{r predictions_m3}
#| echo: FALSE
#| message: FALSE
#| warning: FALSE

post3 <- as.data.frame(fit3, pars = c('S_rep'))
df$urv_est3 <- post3 %>% colMeans
df$propsurv_est3 <- df$urv_est3/df$density

alpha3 <- as.data.frame(fit3, pars = c('alpha_tank')) 
alpha_est3 <- alpha3$alpha %>% mean() %>% plogis

# Create the scatterplot with annotations
p <- ggplot(df, 
            aes(x = index, 
                y = propsurv_est3)) +
  geom_point(data=df, 
          aes(x = index, 
              y = propsurv), color='grey')+
  geom_point(color = 'blue3') +
  geom_hline(yintercept = alpha_est, 
             linetype = "dashed", 
             color = "blue4") +
  # annotate("text", 
  #          x = max(df$index) - 23, 
  #          y = alpha_est + 0.05, 
  #          label = "Promedio de supervivencia en tanques", 
  #          color = "black", 
  #          fontface = "italic", 
  #          hjust = 0) +  
  labs(x = "Tanque", 
       y = "Tasa de Supervivencia") +
  theme(
    axis.title.x = element_text(face = "italic"),
    axis.title.y = element_text(face = "italic")
  ) +
  scale_x_continuous(breaks = c(8, 24, 40), 
                     labels = c("1 <= Pequeño < 16", 
                                "16 <= Mediano < 32", 
                                "32 <= Grande < 48")) +
  geom_vline(xintercept = 16, color = "cyan3")+
  geom_vline(xintercept = 32, color = "cyan3")+
  geom_vline(xintercept = 48, color = "cyan3")+
  # ylim(0, 1) +
  scale_y_continuous(labels = scales::percent_format())

p

```

## Comparativo

A simple vista, pareciera que el modelo sin agrupar y el modelo parcialmente agrupado (jerárquico) tienen comportamientos similares. Podemos graficar las estimaciones de una y otra para ver el comportamiento con mayor detenimiento.

```{r tablas auxiliares}
#| echo: FALSE
#| message: FALSE
#| warning: FALSE

aux <- post3 %>% 
  pivot_longer(cols=1:ncol(post3), 
               names_to="parameter", 
               values_to="value") %>%
  group_by(parameter) %>%
  summarise(m3_q2_5=quantile(value, probs = 0.025),
            m3_q97_5=quantile(value, probs = 0.975)) %>% 
  ungroup() %>% 
  mutate(index=as.numeric(gsub("[^0-9]", "", parameter))) %>%
  left_join(df %>% select(index, density), by="index") %>% 
  mutate(m3_lower = m3_q2_5/density, 
         m3_upper = m3_q97_5/density)

aux2 <- post2 %>% 
  pivot_longer(cols=1:ncol(post2), 
               names_to="parameter", 
               values_to="value") %>%
  group_by(parameter) %>% 
  summarise(m2_q2_5=quantile(value, probs = 0.025), 
            m2_q97_5=quantile(value, probs = 0.975)) %>% 
  ungroup() %>%
  mutate(index=as.numeric(gsub("[^0-9]", "", parameter))) %>%
  left_join(df %>% select(index, density), by="index") %>% 
  mutate(m2_lower = m2_q2_5/density,
         m2_upper = m2_q97_5/density)
```

```{r graficas_comparativo}
#| echo: FALSE
#| warning: FALSE
#| message: FALSE

p1<- ggplot(df, 
       aes(x = index, 
           y = propsurv_est3)) +
  geom_point(data=df, 
             aes(x = index, 
                 y = propsurv), color='grey')+
  geom_point(color = 'blue3') +
  geom_point(aes(x=index, y=propsurv_est2), color='red3') +
  geom_hline(yintercept = alpha_est, 
             linetype = "dashed", 
             color = "blue4") +
  labs(x = "Tanque", 
       y = "Tasa de Supervivencia",
       title="Comparativo entre modelos",
       subtitle="No agrupado = rojo, Jerárquico = azul") +
  theme(
    axis.title.x = element_text(face = "italic"),
    axis.title.y = element_text(face = "italic")) +
  scale_x_continuous(breaks = c(8, 24, 40), 
                     labels = c("1 <= Pequeño < 16", 
                                "16 <= Mediano < 32", 
                                "32 <= Grande < 48")) +
  geom_vline(xintercept = 15.5, color = "cyan3")+
  geom_vline(xintercept = 31.5, color = "cyan3")+
  geom_vline(xintercept = 48.5, color = "cyan3")+
  scale_y_continuous(labels = scales::percent_format())

p3 <- ggplot(df, 
       aes(x = index, 
           y = propsurv_est3)) +
  geom_point(data=df, 
             aes(x = index, 
                 y = propsurv), color='grey')+
  geom_point(color = 'blue3') +
  geom_segment(data=aux,
               aes(x = index,
                   xend = index,
                   y = m3_lower,,
                   yend = m3_upper),
               color = "blue", alpha=0.2, linewidth = 1) +
  geom_hline(yintercept = alpha_est, 
             linetype = "dashed", 
             color = "blue4") +
  labs(x = "Tanque", 
       y = "",
       title="Modelo jerárquico") +
  theme(
    axis.title.x = element_text(face = "italic"),
    axis.title.y = element_text(face = "italic")
  ) +
  scale_x_continuous(breaks = c(8, 24, 40), 
                     labels = c("1 <= Pequeño < 16", 
                                "16 <= Mediano < 32", 
                                "32 <= Grande < 48")) +
  geom_vline(xintercept = 15.5, color = "cyan3")+
  geom_vline(xintercept = 31.5, color = "cyan3")+
  geom_vline(xintercept = 48.5, color = "cyan3")+
  scale_y_continuous(labels = scales::percent_format())

p2 <- ggplot(df, 
       aes(x = index, 
           y = propsurv_est2)) +
  geom_point(data=df, 
             aes(x = index, 
                 y = propsurv), color='grey')+
  geom_point(color='red3') +
  geom_segment(data=aux2,
               aes(x = index,
                   xend = index,
                   y = m2_lower,,
                   yend = m2_upper),
               color = "red", alpha=0.2, linewidth = 1) +
  geom_hline(yintercept = alpha_est, 
             linetype = "dashed", 
             color = "blue4") +
  labs(x = "Tanque", 
       y = "Tasa de Supervivencia",
       title="Modelo no agrupado") +
  theme(
    axis.title.x = element_text(face = "italic"),
    axis.title.y = element_text(face = "italic")
  ) +
  scale_x_continuous(breaks = c(8, 24, 40), 
                     labels = c("1 <= Pequeño < 16", 
                                "16 <= Mediano < 32", 
                                "32 <= Grande < 48")) +
  geom_vline(xintercept = 15.5, color = "cyan3")+
  geom_vline(xintercept = 31.5, color = "cyan3")+
  geom_vline(xintercept = 48.5, color = "cyan3")+
  scale_y_continuous(labels = scales::percent_format())

p1
```

Pero podemos incluir intervalos de credibilidad para ver su comportamiento:

```{r graf_comp2}
#| echo: FALSE
#| message: FALSE
#| warning: FALSE

(p2/p3)
```

## Anexos {#sec-anexos}

### Rethinking y sus datos {#sec-rethinking-y-sus-datos}

Para instalar la librería de *rethinking*, se pueden seguir las instrucciones del repositorio de McElreath, disponible en este [link](https://github.com/rmcelreath/rethinking "Repositorio de rethinking").

Una vez instalada la librería y sus dependencias, los datos de *reedfrogs* se pueden obtener corriendo el siguiente código

```{r anexo1_cargarDatos, eval=FALSE}
library(rethinking)
data(reedfrogs)
```
